[{"headings":["Components"],"content":"A component in Dolph is a specialized class used to organize the application structure and maintain the MVC pattern. It is identified by the `@Component` decorator. Controllers and services associated with an entity are registered within the component for that entity, and all components are registered in the `server.ts` file.\nThis is what a component looks like:\nAnd the component is registered in the `server.ts` file just like this:\ninfo **Hint** Each entity must have a component that registers its associated controller(s) and service(s). All components are then registered in the `server.ts` file.\n","path":"components.","rank":40,"objectID":"d1b8a910971345212cdb562d8742fa2d"},{"headings":["Controllers","Routing","Route Parameters","Request Object","Response Object","Status Codes","SuccessResponse (Response)"],"content":"Controllers handle requests by processing them and returning appropriate responses.\nRouting directs requests and groups of requests to specific controllers capable of managing them.\nIn Dolph, each controller extends the `DolphControllerHandler` class and accepts a generic type of `Dolph`, as shown below:\nDolph uses the `Route()` decorator for routing. This decorator takes a string parameter that serves as a prefix for routes, allowing you to group related routes together. For instance, if you want to group routes related to user functionality, you would pass `user` to the decorator, as shown below:\nIn the example above, to call the greet method and process a request, you would use the path `/user/greet`.\ninfo **Hint** The **Route()** decorator is necessary for your request handler method to be accessible. It’s recommended to create a controller via the CLI using the `$ dolph g -c <name>` command, as this automatically registers the controller class in the component class for you.\nThe `Get()` decorator is a HTTP request method decorator which marks the **greet** method handler as a [get request](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET). When the **Registrar** registers the controller into the dolph engine, a route mapping looking like this is created `GET /user/greet`.\nOur **greet** method doesn't do much except to return a 200 success response with a message that says **you've reached the auth endpoint**.\nThe [SuccessResponse](/status/overview) is used to return a 200 status code with data which in this case is a message.\nThis approach is useful when you need to accept dynamic data as part of a request via the route path (e.g., `GET /user/1` to retrieve the user with the dynamic data `1`). To achieve this, you can use route parameter placeholders, which are denoted by a colon in the route path. For example, the placeholder `:name` in the route `greet/:name` can be accessed using `req.params.name`.\nDolph is built on the [express](https://expressjs.com/en) framework hence giving access to the [request object](https://expressjs.com/en/api.html#req) provided by express. This is easily accessible through the `DRequest` interface exported by dolph.\ninfo **Hint** It is advisable to install the `@types/express` package to take advantage of `express` typings (as in the `req: DRequest` parameter of the **greet** method).\nSeveral core objects can be accessed through the `request` object. Some of which include:\n**query** : This property is an object containing a property for each query string parameter in the route. When [query parser](https://expressjs.com/en/api.html#app.settings.table) is set to disabled, it is an empty object, otherwise it is the result of the configured query parser.\n**params** :  This property is an object containing properties mapped to the [named route](https://expressjs.com/en/guide/routing.html#route-parameters) “parameters”. For example, if you have the route **/user/:name**, then the “name” property is available as req.params.name. This object defaults to an empty object.\n**body** : Contains key-value pairs of data submitted in the request body.\n**payload** : Hold's data deserialized from the auth middleware.\n**cookies** : When using [cookie-parser](https://www.npmjs.com/package/cookie-parser) middleware, this property is an object that contains cookies sent b","path":"controllers.lll","rank":14,"objectID":"568eb592fd969d4a574c5d9eabbcb4c8"},{"headings":["ErrorResponse (Response)","ErrorException (Exception)","BadGatewayException","BadRequestException","ConflictException","ForbiddenException","GoneException"],"content":"y the request. If the request contains no cookies, it defaults to an empty object.\nYou can check out others [here](https://expressjs.com/en/api.html#req) to get full documentation.\nDolph is built on the [express](https://expressjs.com/en) framework hence giving access to the [response object](https://expressjs.com/en/api.html#res) provided by express. This is easily accessible through the `DResponse` interface exported by dolph.\nThe Response Object is literally the HTTP response that is sent by the Dolph app when a request has been received and processed.\ninfo **Hint** It is advisable to install the `@types/express` package to take advantage of `express` typings (as in the `res: DResponse` parameter of the **greet** method).\nSeveral core objects can be accessed through the `response` object. Some of which include:\n**cookie**: Set's a cookie data which is sent along with the response. Check full documentation [here](https://expressjs.com/en/api.html#res.cookie).\n**get**: Returns the HTTP response header specified by field. The match is case-insensitive. Check full documentation [here](https://expressjs.com/en/api.html#res.get).\n**json**: Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a JSON string using **JSON.stringify()**.\nThe parameter can be any JSON type, including object, array, string, Boolean, number, or null, and you can also use it to convert other values to JSON. Check full documentation [here](https://expressjs.com/en/api.html#res.json).\n**redirect**: Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to an [HTTP status code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) . If not specified, status defaults to “302 “Found”. Check full documentation [here](https://expressjs.com/en/api.html#res.redirect).\n**send**: Sends the HTTP response. The body parameter can be a Buffer object, a String, an object, Boolean, or an Array. Check documentation [here](https://expressjs.com/en/api.html#res.send).\n**status**: Sets the HTTP status for the response. It is a chainable alias of Node’s response.statusCode. Check full documentation [here](https://expressjs.com/en/api.html#res.status).\nTo get full documentation on the `request` object, check the official express documentation [here](https://expressjs.com/en/api.html#res.status).\nAll the HTTP status codes are documented [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status). When sending requests, using the already defined response senders by dolph, you may not need to pass the status codes manually. Below are such utiliy classes:\nThe `SuccessResponse` class is a utility designed to streamline the process of sending successful HTTP responses in your application. It provides a standardized structure for responses, including the status, body, and message.\n<strong>Usage</strong>\nSending a success response with body and message:\nSending a success response with only body:\nSending a success response with only message:\nSending a success response with neither body nor message:\ninfo **Hint** If the status field is not passed, the default status code is set to `200` as seen here:\nThis works exactly like the `SuccessResponse` utility class with the exception that it defaults to **400** status code when the **st","path":"controllers.llr","rank":14,"objectID":"568eb592fd969d4a574c5d9eabbcb4c8"},{"headings":["HttpVersionUnSupportedException","ImTeaPotException","InternalServerErrorException","MethodNotAllowedException","MisDirectedException","NotAcceptableException","NotFoundException"],"content":"atus** field is omitted.\nExample:\nThe ErrorException class extends the `DefaultException` class and is intended for representing custom error exceptions in your application. It provides a mechanism to create error instances with additional properties, such as status code, operational status, and stack trace.\n<strong>Constructor Parameters</strong>\n**message**: string - A descriptive message for the error.\n**statusCode (optional)**: number - HTTP status code associated with the error.\n**isOperational (optional)**: boolean - Indicates whether the error is operational (default:  true). Operational errors are intended to be handled gracefully, while non-operational errors may indicate unexpected issues.\n**stack (optional)**: string - The stack trace for the error. If not provided, the constructor automatically captures the stack trace.\nIn a typical dolph application you'll see it called with only the `message` and `statusCode` parameters as seen below:\ninfo **Hint** Custom error instances can be created by instantiating the ErrorException class with relevant parameters. The stack trace is automatically captured unless provided explicitly.\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `502` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `400` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `409` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `403` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `410` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `410` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `418` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `500` status code as seen below:\nThis u","path":"controllers.rrl","rank":14,"objectID":"568eb592fd969d4a574c5d9eabbcb4c8"},{"headings":["NotImplementedException","PaymentRequiredException","ServiceUnavaliableException","TimeOutException","UnauthorizedException","UnSupportedMediaException","Asynchronicity"],"content":"tility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `405` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `421` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `406` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `404` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `501` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `402` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `503` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `504` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `401` status code as seen below:\nThis utility class extends the `DefaultException` class as the `ErrorException` does too,  but unlike the **ErrorException** class, in a typical dolph application, only the message param get's passed to this function because it defaults to a `415` status code as seen below:\ninfo **Hint** It's recommended to use exceptions over `ErrorResponse` when returing 4\\*\\* and 5\\*\\* status codes to maximize dolphjs error handling mechanisms.\nDue to the way Node.js works, most functions / methods are usually asynchronous in nature hence the 100% compatibility Dolph has with `async` functions.\ninfo **Hint** Learn more about `async / await` feature [here](https://kamilmysliwiec.com/typescript-2-1-introduction-async-await)\nEvery async function has to return a `Promise`. This means that you can return a deferred value that Dolph will be able to resolve by itself. Let's see an example of this:\n","path":"controllers.rrr","rank":14,"objectID":"568eb592fd969d4a574c5d9eabbcb4c8"},{"headings":["Decorators","Class Decorators","Method Decorators","InjectServiceHandler","Usage","UseMiddleware","MediaParser","Usage","TryCatchDec and TryCatchAsyncDec","Usage"],"content":"Dolph utilizes a variety of [decorators](https://www.typescriptlang.org/docs/handbook/decorators.html#handbook-content)  to implement numerous features. We’ve already encountered some of these decorators in previous sections, including **Component**, **InjectMongo**, **InjectMysql**, **Route**, **Get**, among others.\nThese decorators directly affect the class itself. A class decorator is typically declared at the top of the class definition. Below is a list of all the current class decorators offered by Dolph:\nThese decorators directly affect the class method they are declared on. In Dolph, a method can have multiple decorators attached, so it’s crucial to maintain the correct order to ensure your code functions as expected. Below is a list of these decorators:\nAs you can see, there are many decorators that you may be encountering for the first time. In the sections below, we will discuss each of these decorators in detail, providing appropriate examples for better understanding.\nThe `InjectServiceHandler` function is a decorator factory used to inject service handlers into a class instance. It takes an array of `DolphServiceMapping` objects, each specifying a service name and its corresponding handler class. The injected service handlers become accessible as properties of the decorated class instance.\nThe `InjectServiceHandler` function returns a class that extends the provided base class. During the instantiation of this extended class, it creates instances of the specified service handlers and injects them as properties with the specified service names.\ninfo **Hint** Ensure that the service mappings provided match the property names in the decorated class where the service handlers will be injected.\nWe’ll illustrate a scenario where this can be used. While it is primarily employed in the [Express routing system](https://github.com/dolphjs/dolph#readme-ov-file), it can also be applied in Spring routing for managing multiple services within a single component.\nFor example, let’s say we update our project with a service called msg:\nWe create an `Index.service` file which would act as an index service:\nFrom the code above, we see that the services are injected into the **IndexService** class using the decorator and now we can update our controller as seen below:\ninfo **Hint** This is only recommended when you have more than **one** service class within your component and yet still, it's meant to be used with `express routing` architecture.\nThe **UseMiddleware** decorator is designed to be used with class methods, particularly those handling HTTP requests or middleware execution. It allows you to attach one or more middleware functions to a specific method, enhancing the functionality of the method with additional processing logic.\ninfo **Hint** Multiple middleware functions can be attached to a single method, and their execution order follows the order of attachment.\nLet's create a `dummy` middleware function to show how this works:\nThen let's update our controller:\nNow, try sending a request without the `name` field and you'll receive a `BadRequestException` with the message *please provide name in request body*.\nThe **MediaParser** function is designed as a method decorator for Dolph controllers. It handles the parsing and processing of media files in the request body, supporting both single and multiple file uploads. This function integrates with the \\[Multer]\\(https://www.npmjs.com/package/multer/)  middleware for file upload processing and includes error handling for unsupported file types.\nThe `IMediaParserOptions` interface:\n**fieldname** - The name of the field in the form containing the media file(s).\n**type** - Indicates whether the parser should handle a single file or an array of files.\n**extensions** - An array of allowed file extensions. Defaults to a set of common image file extensions.\n**limit**  - The maximum number of files to be uploaded (applicable for type 'array'). `Defaults to 10`.\n**storage** - Custom storage engine configuration for **Multer**.\nThe **@MediaParser** decorator acts as a method decorator, wrapping the original method with additional logic for handling media files. It verifies the request's content type, validates file extensions, and utilizes Multer middleware for file upload processing.\nLet's implement this with our **newUser** method so that we can upload files:\ninfo **Note** We have provided values only for the required parameters and left the optional parameters empty, but you can adjust them based on your needs. When sending the file, the name assigned will be the value of **fieldname**, which in our case is `upload`. Additionally, ensure that your decorators are ordered correctly to avoid errors.\nThe **TryCatchAsyncDec** decorator is designed to be used with asynchronous methods in a class. It wraps the original asynchronous method, catching any errors that might occur during its execution. This helps in handling errors gracefully and forwarding them to the next middleware or Dolph's error-handling mechanism.\nThe **TryCatchAsyncDec** decorator works by replacing the original asynchronous method with a new asynchronous function that wraps it in a try-catch block. If an error occurs during the execution of the original method, the error is caught, and the next function is called to pass the error to the next middleware or Dolph's error-handling mechanism.\nThe **TryCatchDec** is just a **TryCatchAsyncDec** that works for synchronous code and not asynchronous as the later does.\nThis means that you don't need to explicitly write the `try-catch` block yourself but can add it to your method by just calling the decorator.\ninfo **Hint** These decorators are **top-level** decorators and should be placed above all other decorators except the route decorators.\nThis concludes this section. Any other decorators not covered here will be addressed in subsequent sections, as they are broader and rely heavily on the availability of additional functions.\n","path":"decorators.","rank":17,"objectID":"a593262b97a8f3ec1e2657c7b6ab1472"},{"headings":["Guide","Language","Prerequisites","Setup","Architectures","Running the application"],"content":"In this section, we'll explore the **core fundamentals** of Dolph. To illustrate the essential building blocks of the framework, we'll walk through creating a basic **CRUD** application, showcasing the key features of Dolph at an introductory level.\n[Typescript](https://www.typescriptlang.org/) is the default and recommended language for Dolph projects.  However, Dolph is also compatible with pure JavaScript using the `express` style and can run on  [Node.js](https://nodejs.org/en/).\nWhile most of our examples and sample code will be written in TypeScript, adhering to TypeScript conventions, you can easily switch the code snippets to vanilla JavaScript. Simply click the language toggle button in the upper right-hand corner of each snippet.\n[Node.js](https://nodejs.org) (version >= 18)\n[Dolph CLI](/cli/overview) (version >= 1.2.4)\nTo set up a new project, you will use the **Dolph CLI**. Below, we’ll install the CLI and create a new project with it:\ninfo **Hint** To create a new project in your current directory, use a `.` in place of `project name`.\nThe `project name` directory will be created, along with some configuration files and subfolders.We'll assume you choose the default and recommended dolph structure [spring](/spring/overview)\nA summary on the generated files and directories:\n|                          |                                                                                                                     |\n| ------------------------ | ------------------------------------------------------------------------------------------------------------------- |\n| `.gitignore`      | The git ignore file used to specify files & folders git should ignore when pushing to remote repo.                                                                           |\n| `.swcrc` | Config file for the swcrc package used by dolph.                            |\n| `dolph_cli.yaml`          | The dolph CLI config file.                                                                                 |\n| `dolph_config.yaml`         | The dolphjs config file.                                                                               |\n| `package.json`                | Config file which holds info about the application. |\n| `tsconfig.json`                | Typescript config file. |\n| `src`                | Holds code written by developer. |\n| `tests`                | Holds tests for codes. |\n| `src/components`                | Contains all the individual components of the project. |\n| `src/shared`                | Files that would be shared amongst components are placed here. |\n| `tests/unit`                | Unit tests are written here. |\n| `tests/integration`                | Integration tests are written here. |\n| `sever.ts`                | The entry file of the application which uses the core function DolphFactory to create a Dolph application instance.. |\nThe `server.ts` registers components and services as well as starts the **Dolph core engine**:\nTo create a new Dolph application instance, instantiate the `DolphFactory` class. This class provides several methods for configuration and other functionalities. Calling the start method will initialize the `Dolph core engine`.\nWe strive to be as inclusive as possible, which is why Dolph projects support two architectures:  [spring](/architectures/spring) and [express](/architectures/express). This flexibility allows developers to choose based on their preferences.\ninfo **Note** The Spring architecture is the recommended approach for building DolphJS applications. It offers numerous utilities, functions, and features designed to accelerate development and enhance the overall experience.\nDolph is built on the [express](https://expressjs.com/) framework.\nThe `dolph new <project name>` command sets up your project with the chosen architecture and configuration files. To run the application, you need to install the necessary packages. Navigate to the project directory and execute:\nAfter installing the packages, you may want to generate sample files. You can do this using the following command:\nThe command above generates a component with the following files: controller, service, model, and registers the controller class within the component class.\ninfo **Hint** In the current version, you need to manually import the component into the server file. The example below assumes you ran `dolph generate -a auth`:\nYou can now run `dolph start` to launch the application on the default port, or use `dolph watch` to run it in [watch mode](/cli/overview). After starting the server, open your browser and navigate to localhost:3030/auth/greet to receive a message from the server.\n","path":"guide.","rank":74,"objectID":"8c27d0d0b409c1de1867fdc9a128c72c"},{"headings":["Introduction","Architectural Foundations","Prerequisites","Installation"],"content":"Dolph.js is a Node.js framework built on top of the Express framework, designed to maintain simplicity and efficiency in developing server-side applications while enforcing clean-code architecture. Developed with [TypeScript](http://www.typescriptlang.org/), Dolph.js offers full support for both TypeScript and JavaScript, combining Object-Oriented Programming (OOP) and Functional Programming (FP) paradigms.\nDolph.js strives to maintain compatibility with libraries and packages that work with [Express](https://expressjs.com/en/) and shares many similarities with it. As a result, developers with prior experience in **Express** will find the learning curve for Dolph.js very approachable.\nServer-side development using Node.js has become easier in recent years with the rise of popular frameworks like [Fastify](https://fastify.dev/), [Express](https://expressjs.com/en/) and [Nest](https://nestjs.com/). Dolph.js aims to address architectural challenges while retaining simplicity and efficiency. It is inspired by **Nest** and **Express** and is built on top of the **Express** framework. Currently, Dolph.js is in its beta stage, with many exciting features planned for the near future.\n[Node.js](https://nodejs.org) (version >= 18)\n[Dolph CLI](/cli/overview) (version >= 1.2.4)\nTo set up a new project, use the [Dolph CLI](/cli/overview). Below, we’ll install the CLI and create a new project with it:\ninfo **Hint** To create a new project in your current directory, use a `.` in place of `project name`.\nThe `project name` directory will be created, along with some configuration files and subfolders.\n","path":"introduction.","rank":23,"objectID":"2767292a573dc549b9b4297b701af3ab"},{"headings":["Middlewares","Global Middlewares"],"content":"A middleware is a function that executes before the route handler. It allows you to run additional logic, modify the **request** or **response** objects, or terminate the **request-response** cycle. Middleware is essential for enhancing the functionality, security, and customization of APIs.\nMiddlewares can be attached to any controller method that serves as a route. You can achieve this using the `@UseMiddleware decorator`, as shown below:\nThe **@UseMiddleware** decorator in the Dolph framework allows you to attach middleware functions to specific controller methods. This enables additional processing, validation, or other operations on requests before they reach your controller logic.\nA global middleware is a middleware that is not restricted to specific controller methods but runs on every request. This can include security middlewares such as rate-limiting, XSS-cleaning, and more.\nRegistering a global middleware in your Dolph server is straightforward, as demonstrated below using the Helmet security package:\ncalling the `register` method and passing the middleware as a param registers the middleware.\ninfo **Hint** All Global middlewares must be registered before calling the `DolphFactory` class.\n","path":"middlewares.","rank":59,"objectID":"a26fd2e9fd8eb07c11f1cb8b4bdbc51a"},{"headings":["Models","Using models with services","MongoDb Model","MySQL Model"],"content":"Models define the structure and validation rules for data stored in the database. Each model corresponds to a specific entity or collection, offering a consistent and structured approach to interact with the underlying data storage. By default, Dolph uses [Mongoose ODM](https://mongoosejs.com/) for **MongoDB** interactions and schema design, and [Sequelize ORM](https://sequelize.org/) for **MySQL** and **PostgreSQL** interactions and schema design.\nExample of a mongoose model:\nExample of mysql model:\n<strong>IUser</strong>\nIt's conventional to name the document interfaces  by starting with an **I** and following with the uppercase for the first letter of the entity.\n**IUser Interface**: Defines the structure of the document using TypeScript. It extends the Document interface provided by Mongoose.\n**UserSchema**: Describes the schema for the model using the Mongoose Schema class. It includes the fields (name and email) with their respective data types and validation rules.\n**UserModel Export**: Creates a Mongoose model named \"users\" based on the defined schema. The model is exported for use in other parts of the application.\nIn this example, we'll show how to us  inject a **mongoose** and **mysql** model into our `UserService` file:\nLet's breakdown what we have in the code above:\n**InjectMongo** - this decorator is used to inject a **mongo model** into the service class. The **InjectMongo** decorator is used to inject a MongoDB model into a Dolph service class, facilitating seamless interaction with the specified MongoDB collection. It simplifies the process of accessing and manipulating data within the MongoDB database.\n**userModel** - the property name used to bind the injected model within the service class.\n**UserModel** -  the Mongoose model representing the MongoDB collection to be injected.\n**Model\\<IUser>** - A Mongoose model representing the structure and behavior of the MongoDB collection for user data.\nThe **userModel** property is a protected, readonly property within the `UserService` class. It holds the Mongoose model for the MongoDB collection associated with user data. This property is injected and bound using the `@InjectMongo()` decorator.\ninfo **Hint** Ensure that the property name used in **@InjectMongo(\"userModel\", UserModel)** matches the property name within the service class **(protected readonly userModel!: Model\\<IUser>)**.\nLet's breakdown what we have in the code above:\n**InjectMysql**: this decorator is used to inject a Sequelize model into a Dolph service class, facilitating interaction with the specified **MySQL** database table. This decorator simplifies the process of accessing and manipulating data within the **MySQL** database.\n**userModel** - the property name to bind the injected model to within the service class. The userModel property is a public property within the UserService class. It holds the Sequelize model for the **MySQL** table associated with user data. This property is injected and bound using the `@InjectMySQL()` decorator.\n**ModelStatic\\<Model\\<any, any>>**: A Sequelize model representing the structure and behavior of the MySQL table for user data.\ninfo **Hint** Ensure that the property name used in **@InjectMySQL(\"userModel\")** matches the property name within the service class **(userModel!: ModelStatic\\<Model\\<any, any>>)**. The [Sequelize](https://sequelize.org/) model comes with built-in methods for CRUD operations, making it convenient to interact with the MySQL database.\n","path":"models.","rank":66,"objectID":"51a6638e467c1c44d967197424e8e0e5"},{"headings":["Pipes"],"content":"","path":"pipes.","rank":51,"objectID":"51c3a019cf6be40f74e719df929c55bb"},{"headings":["Services"],"content":"Services are a core concept in Dolph and central to its architecture. A service is any class that extends the `DolphServiceHandler` class. These classes handle direct communication with databases, third-party APIs, and more. Typically, a service class will have the relevant database model(s) registered to it.\nThe purpose of a service class is to consolidate all code related to a particular controller into a single service, allowing methods to share code and functionality.\nLet’s walk through a sample service class for a ***user*** entity:\ninfo **Hint** To create a service using the CLI, simply execute the `$ dolph g -s user` command.\nThe `UserService` class is a basic example of a service class. Here is what the `User` interface looks like:\nWe have to register the `UserService` class in our component in order to make use of it within our controller:\nAny service registered in a component is accessible to all controllers within that component. The name given to the service in the controller class must match its name exactly. For example, a service named UserService should be referred to as **UserService** in the controller class, not as ***userService*** or any other variation.\nThis is what our directory structure looks like now:\n","path":"services.","rank":8,"objectID":"bfc9941b6b6fd7b4ef09dd0ccd08af0c"},{"headings":["Shields","Usage"],"content":"A shield is a specialized middleware decorator used to attach authentication and authorization middleware at the controller level. This means it affects all methods (routes) within the controller class.\nCurrently, it has limited functionality, but with the introduction of version **1.6**, the Dolph shield package will be available to handle authentication and authorization in a more streamlined and user-friendly manner.\n`@dolphjs/shield`\n","path":"shields.","rank":35,"objectID":"2a3601d750cef22b49f2f84526b53c71"}]